
#include "misc.h"
#include "print_debug.h"
#include "RTC_SAM3X.h"
#include "JSON_tools.h"
#include "Alerts.h"
#include "timers.h"
#include "Buzzer.h"
#include "HUB.h"


#define LOW 1
#define MEDIUM 2
#define HIGH 3
#define VERY_HIGH 4

Reference_group *RG = NULL;
short int N_groups;

Condition *conditions = NULL;
short int N_conditions;

bool verbose_alert = false; // true;


//***********************************************************************
//  Determine the number of groups                               
//***********************************************************************
void set_groups(Reference_group G[], Alert alerts[], short int N_alerts, Sensor sensors[], short int N_sensors)
{
    short int i, j, k;

    for (i = 0; i < N_alerts; i++)
        if (alerts[i].reference_group != "")
        {
            for (j = 0; j < N_alerts; j++)
            {
                if (G[j].name == "")
                {
                    G[j].name = alerts[i].reference_group;
                    G[j].is_sensor = alerts[i].is_sensor;
                    G[j].digital = alerts[i].digital;
                    G[j].index[0] = i;
                    G[j].N = 1;
                    N_groups++;
                    break;
                }
                else if (G[j].name == alerts[i].reference_group)
                {
                    k = G[j].N;
                    G[j].index[k] = i;
                    G[j].N++;
                    break;
                }
            }
        }

//**Groups with name which is a magnitude.
//  These groups have every sensor with this magnitude 
    for (j = 0; j < N_groups; j++)
    {
        k = 0; 
        for (i= 0; i < N_sensors; i++)
            if (sensors[i].magnitude == G[j].name) 
            {
                G[j].index[k] = i; 
                k++; 
                Serial.print(i); Serial.print("  "); Serial.println(sensors[i].magnitude); 
            }

        if (k > 0)
        {
            G[j].N = k; G[j].any = true;
        }
        else  G[j].any = false;
    }
      

}

//***********************************************************************
//   Determine the number of conditions                             
//***********************************************************************
void set_conditions(Condition C[], Alert alerts[], short int N_alerts)
{
    short int i, j, k;

    for (i = 0; i < N_alerts; i++)
        if (alerts[i].condition != "")
        {
            for (j = 0; j < N_alerts; j++)
            {
                if (C[j].name == "")
                {
                    C[j].name = alerts[i].condition;
                    C[j].N = 1;
                    C[j].index[0] = i; 
                    N_conditions++;
                    break;
                }
                else if (C[j].name == alerts[i].condition)
                {
                    k = C[j].N;
                    C[j].index[k] = i;
                    C[j].N++;
                    break;
                }
            }
        }
               
}




// **********************************************************************************************************
// Asign values to each Alert field
// **********************************************************************************************************
void alerts_setup( Alert alerts[], short int N_alerts, JSON_Row config [], Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators )	
{	
	short int i, j, k;
    Reference_group *mRG;
	Condition *mC;
    String magnitude; 

	N_groups = 0;
	N_conditions = 0;

    mRG = new Reference_group[N_alerts]; 
	mC = new Condition[N_alerts];
    
	for (i = 0; i < N_alerts; i++)
    {
		mRG[i].name = "";
        mRG[i].index = new short int[N_sensors];

		mC[i].name = "";
		mC[i].index = new short int[N_alerts];
    }

	for ( i = 0; i < N_alerts; i++ )
	{
		alerts[i].name            = config[i].c[0];
		alerts[i].min_value       = config[i].c[1];
		alerts[i].max_value       = config[i].c[2];
		alerts[i].value           = config[i].c[3];
		alerts[i].reference_group = config[i].c[4];
		alerts[i].condition       = config[i].c[5];
		alerts[i].time_begin      = config[i].c[6];
		alerts[i].time_end        = config[i].c[7];
		alerts[i].days            = config[i].c[8];
		alerts[i].mode            = config[i].c[9];
		alerts[i].actions         = config[i].c[10];
		alerts[i].report          = config[i].c[11];
		
		
		for (j = 0; j < N_sensors; j++)
			if (alerts[i].name == sensors[j].label)
			{
				alerts[i].is_sensor = true;
				alerts[i].index = j;
				alerts[i].magnitude = sensors[j].magnitude;
               // if min value is blank, then the sensors is digital
				if (alerts[i].min_value == "") alerts[i].digital = true;     
				else                           alerts[i].digital = false;
			}

		for (j = 0; j < N_actuators; j++)
			if (alerts[i].name == actuators[j].label)
			{
				alerts[i].is_sensor = false;
				alerts[i].digital = true;      // an actuator is always digital 
				alerts[i].index = j;
				alerts[i].magnitude = actuators[j].device;
			}

        if (alerts[i].name == "ANY")
        {
          magnitude = alerts[i].reference_group;
          
          alerts[i].is_sensor = true;
          if (magnitude == "Door" || magnitude == "Alarm") 
                alerts[i].digital = true; 
          else  alerts[i].digital = false;
          alerts[i].magnitude = magnitude;
        }
           
		
		
	}

    set_groups(mRG, alerts, N_alerts, sensors, N_sensors);
    set_conditions(mC, alerts, N_alerts); 

    RG = new Reference_group[N_groups];
	conditions = new Condition[N_conditions];

    for (j = 0; j < N_groups; j++)
    {
		RG[j].name      = mRG[j].name;
		RG[j].is_sensor = mRG[j].is_sensor;
        RG[j].digital   = mRG[j].digital;
		RG[j].N         = mRG[j].N; 
        RG[j].any       = mRG[j].any; 
        RG[j].index      = new short int[RG[j].N];

        Serial.println(RG[j].name); 

        for (i = 0; i < RG[j].N; i++)
        {
            Serial.print(str("index =") );  Serial.println(mRG[j].index[i]); 
            RG[j].index[i] = mRG[j].index[i];
        }
    }

	for (i = 0; i < N_conditions; i++)
	{
		conditions[i].name  = mC[i].name;
		conditions[i].N     = mC[i].N;
		conditions[i].index = new short int[conditions[i].N];
	    for (j = 0; j < conditions[i].N; j++) conditions[i].index[j] = mC[i].index[j]; 
	}

    for (i = 0; i < N_alerts; i++) alerts[i].ini();

	Serial.print(str("Number of reference groups: ")); Serial.println(N_groups);
    for (j = 0; j < N_groups; j++) 
    { 
        Serial.println(RG[j].name); 
        for (i = 0; i < RG[j].N; i++)
        {
            k = RG[j].index[i];
            if (RG[j].any)
            { 
                Serial.print(str("  sensor =   ")); Serial.print(sensors[k].label); Serial.print(str("   ")); Serial.println(k);
            }
            else
            {
                Serial.print(str("  alert =   ")); Serial.print(alerts[k].name); Serial.print(str("   ")); Serial.println(alerts[k].index);
            }
            
        }
    }
   

	Serial.print(str("Number of conditions: ")); Serial.println(N_conditions);
    for (i = 0; i < N_conditions; i++)
    {
        Serial.println(conditions[i].name);
        for (j = 0; j < conditions[i].N; j++)
        {
            k = conditions[i].index[j];
            Serial.print(str("   ")); 
            Serial.println(alerts[k].name); Serial.print(str("   ")); Serial.println(alerts[k].index);
        }
    }
   
   

}

//***********************************************************************
//                                
//***********************************************************************
void Alert :: ini()
{
    short int j; 
    
    if (time_begin != "")
    {
       Time_to_decimal( time_begin, t_begin );
	   Time_to_decimal( time_end, t_end );
    }
	

    if (min_value != "")
    {
        String_to_float(max_value, v_max);
        String_to_float(min_value, v_min);
    }

    for (j=0; j<N_groups; j++)
    {
        if (RG[j].name == reference_group) index_reference_group = j; 
        break;
    }

    reset_values(); 
}



//************************************************************************
//
//************************************************************************
void set_reference_group_values(float DT, Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators, Alert alerts[], short int N_alerts)
{
	short int i, j, k, l;
    float sum; 


//  Reference groups: mean values 
    for (i = 0; i < N_groups; ++i)
    {
      if (verbose_alert)   Serial.println(RG[i].name); 
      sum = 0; 
      for (j = 0; j < RG[i].N; ++j)
        {
            k = RG[i].index[j]; 

            if (RG[i].any) l = k; 
            else           l = alerts[k].index;

            if ( !RG[i].digital ) sum += sensors[l].value;
            else                  sum += alerts[k].seconds_on;
            if (verbose_alert) Serial.println(sum);
        }
      RG[i].mean = sum / RG[i].N; 
    }
 
//  Reference groups: typical deviation 
    for (i = 0; i < N_groups; ++i)
    {
		sum = 0; 
		for (j = 0; j < RG[i].N; ++j)
        {
            k = RG[i].index[j];

            // If the reference group is ANY, then indexes are sensors indexes 
			// else indexes are alerts which correspond to some sensors 
			if (RG[i].any) l = k;
			else           l = alerts[k].index;
           
            if (!RG[i].digital) sum += pow(sensors[l].value - RG[i].mean, 2.0); 
            else                sum += pow(alerts[k].seconds_on - RG[i].mean, 2.0); 
        }
        RG[i].deviation = sqrt( sum / RG[i].N ); 
    }

    if (verbose_alert) 
    {
      Serial.println(str("Reference groups are built"));
      for (i = 0; i < N_groups; i++)
      {
          Serial.print(RG[i].name); 
          Serial.print(str("  mean =")); Serial.print(RG[i].mean);
          Serial.print(str("  digital =")); Serial.print(RG[i].digital);
          Serial.print(str("  deviation =")); Serial.println(RG[i].deviation);
      }
    }
        

    //  max, min, mean and deviation from its reference group 
    //  If they actuators or digital sensors, total time while they are ON 
    for (i = 0; i < N_alerts; i++)  alerts[i].set_maxmin(DT, sensors, N_sensors, actuators, N_actuators);
	
    
}



//*******************************************************************
//
//*******************************************************************
void Alert :: set_maxmin(float DT, Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators)
{
	char buff[100]; 
	char cname[20]; 
	

	if (report != "NONE")
    {
        //Serial.print(str("Set values of ")); Serial.print(name);
        //Serial.print(("  is sensor ? digital ? "));  Serial.print(is_sensor); Serial.println(digital);
              
        if (is_sensor && !digital) set_maxmin_sensors(sensors, N_sensors);

        else                       set_maxmin_actuators(DT, actuators, sensors );

		//Serial.print((" max="));  Serial.print(max); 
		//Serial.print((" min="));  Serial.println(min);
		name.toCharArray(cname, 20); 
		sprintf(buff, "Set values of %s is sensor=%d digital=%d  max=%.2f  min =%.2f\n",
			   cname, is_sensor, digital, max, min); 

		Serial.print(buff); 

    }

}



//*******************************************************************
//
//*******************************************************************
void Alert::set_maxmin_sensors(Sensor sensors[], short int N_sensors)
{
    short int i, j;
    float v;

    if (name == "ANY")
    {
        for (i = 0; i < N_sensors; i++)
            if (sensors[i].magnitude == magnitude)
            {
                v = sensors[i].value; 
                set_maxmin_sensor(v); 
            }
    }
    else
    {
        v = sensors[index].value;
        set_maxmin_sensor(v);
    }


}


//*******************************************************************
//
//*******************************************************************
void Alert::set_maxmin_sensor( float v )
{
    short int j; 
  
    if      (v > max) max = v; 
    else if (v < min) min = v;
    
    sum += v;
    N_samples++;
    mean = sum / N_samples;

    j = index_reference_group; 
    deviation = 100 * (RG[j].mean - v) / RG[j].mean; 

    //Serial.print(str("v =")  );   Serial.println(v); 
    //Serial.print(str("min =") );  Serial.println(min);
    //Serial.print(str("max =") );  Serial.println(max); 
    //Serial.print(str("mean ="));  Serial.println(mean);
    //Serial.print(str("deviation ="));  Serial.println(deviation);
    
}

//*******************************************************************
//
//*******************************************************************
void Alert :: set_maxmin_actuators( float DT, Actuator actuators[], Sensor sensors[])
{
    short int j;

    if (!is_sensor) set_actuator_timer( DT, actuators); 
    else            set_digital_sensor_timer(DT, sensors); 

    j = index_reference_group;
    deviation = 100 * (RG[j].mean - seconds_on) / RG[j].mean;
    
}



//*******************************************************************
//
//*******************************************************************
void Alert :: set_actuator_timer( float DT, Actuator actuators[] )
{
	const unsigned char _on = '1', _down = '2', _off = '0';

    bool actuator_on; 

    actuator_on = actuators[index].state == _on || actuators[index].state == _down; 

    if (actuator_on) seconds_on += DT; 

}

//*******************************************************************
//
//*******************************************************************
void Alert :: set_digital_sensor_timer(float DT, Sensor sensors[])
{
	const float _on = 1.0, _off = 0.0, _open = 1.0, _close = 0.0;
	float sensor_value;
	unsigned int milliseconds;

    bool sensor_on; 


	if      (value == "ON")		sensor_value = _on;
	else if (value == "OFF")	sensor_value = _off;
	else if (value == "OPEN")	sensor_value = _open;
	else if (value == "CLOSE")	sensor_value = _close;

    sensor_on = sensors[index].value == sensor_value; 

    if (sensor_on) seconds_on += DT; 

}



// ***********************************************************************
//                                
// ***********************************************************************
void Alert :: check(Time_Date timedate, char main_switch[], Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators)
{
	String periodicity[10] = { "Daily", "Mon-Fri", "Sat-Sun",  "Mon", "Tue", "Wed",  "Thu", "Fri", "Sat", "Sun" };
	short int iday, iday_of_week, i;
	char char_mode[7];
	float dec_hour, v;

	//Determines the state of the days mode
	iday = find_indexs( days, periodicity, 10 ) - 2;
	iday_of_week = timedate.dayOfWeek;

	//Establish the current time as a decimal
	dec_hour = timedate.hour + timedate.minute / 60.;					

	mode.toCharArray( char_mode, 7 );

    // Check alert if main_switch mode coincides with alert mode 
    if ( !strcmp( char_mode, main_switch ) || mode == "ANY" )
    {
		//Check if the current day if the day selected in the alert or in the range of days selected
        if ( (iday < -2 || iday>7 ) && verbose_alert) {  print(str(" ERROR Alert::check  iday ="));  println(iday); }

        if      ( days == "Daily" )				      		     enforceable = true;
        else if ( days == "Mon-Fri" && iday_of_week <= 5 )		 enforceable = true;
        else if ( days == "Sat-Sun" && iday_of_week >= 6 )		 enforceable = true;
        else if ( iday == iday_of_week )						 enforceable = true;
        else													 enforceable = false;
		
        if ( enforceable )
        {
            if ( time_begin == "" )                              enforceable = true;

            // Current time is between its enforceable range
            else if ( dec_hour >= t_begin && dec_hour <= t_end ) enforceable = true;		
            else												 enforceable = false;
            
        }
    }
    else enforceable = false; 


	if (enforceable && actions != "NONE")
	{
		if (is_sensor == true) check_sensors(sensors, N_sensors);
		else                   check_actuators(actuators, N_actuators);
        
        if (verbose_alert)
	    {
        if (is_sensor) v = (float)sensors[index].value; 
        else           v = (float)actuators[index].state;
        Serial.println(str("__________________________")); 
		Serial.print(str("Alert: ")); Serial.print(name); 
        Serial.print(str("  Activation is: "));  Serial.print(on);
        Serial.print(str("  Value=")); Serial.println(v);
        Serial.print(str("  index=")); Serial.println(index);
        
	    }
		
	}
    else on = false; 
}



//***********************************************************************
//                                
//***********************************************************************
void Alert :: check_sensors_value(float f)
{
    const float _on = 1.0, _off = 0.0, _open = 1.0, _close = 0.0, _null = 10;

    if      (value == "NOTNORMAL")  on = notnormal(f);
    else if (value == "ON")	        on = f == _on;
    else if (value == "OFF")	    on = f == _off;
    else if (value == "OPEN")	    on = f == _open;
    else if (value == "CLOSE")	    on = f == _close;
    else                            on = f == _null;


}

//***********************************************************************
//                                
//***********************************************************************
void Alert :: check_actuators_value(unsigned char c)
{
    const short int _up = 1, _down = 2, _on = 1, _off = 0, _null = 10;
      
       
        if      (value == "NOTNORMAL") on = notnormal(seconds_on);
        else if (value == "UP")		   on = c ==_up;
	    else if (value == "DOWN")	   on = c == _down;
	    else if (value == "ON")		   on = c == _on;
	    else if (value == "OFF")	   on = c == _off;
        else                           on = c == _null; 

}



//*********************************************************************************
//		Shows if a value between the same kind of sensors is not normal                  
//*********************************************************************************
bool Alert :: notnormal(float v)
{
    short int i;
    float xmax, xmin;

    for (i = 0; i < N_groups; ++i)
        if (reference_group == RG[i].name)
        {
            xmin = RG[i].mean - 3.0 * RG[i].deviation;
            xmax = RG[i].mean + 3.0 * RG[i].deviation;

            if (v < xmin || v > xmax) return true;
            else                      return false;
        }

    return false;

}

//***********************************************************************
//                                
//***********************************************************************
void Alert :: check_sensors(Sensor sensors [], short int N_sensors)
{
	
	float fvalue, v, vm;
	short int i;
    //char buff[100]; 

    //** check range of sensors between max and min 
    if (min_value != "" && max_value != "")
    {
        //** check if there is at least one sensor out of range 
        if (name == "ANY")
        {
           on = false; index = 0; vm = 0;
           //sprintf(buff, " v_min = %8.2f v_max = %8.2f \n", v_min, v_max);
           //Serial.println(buff);
           for (i = 0; i < N_sensors; i++)
               if (sensors[i].magnitude == magnitude)
               {
                   v = sensors[i].value;
                   if (v < v_min || v > v_max)
                   {
                       if (abs(v) > vm) { index = i; vm = abs(v); }
                       on = on || true;
                   }
                   else  on = on || false;
                   //sprintf(buff, " v = %8.2f vm= %8.2f index= %d \n", v, vm, index); 
                   //Serial.println(buff); 
               }
        }

        //** check if the specific sensors is out of range 
        else if (sensors[index].value < v_min || sensors[index].value > v_max) on = true; 
        else                                                                   on = false; 
    }

    //** check if sensors are or not normal, on, off, open, close  
    else
    {
        //** check if there is at least one sensor with the alert 
        if (name == "ANY") 
        {
            for (i = 0; i < N_sensors; i++)
            {
                check_sensors_value(sensors[i].value);
                if (on) { index = i; break;  }
            }
        }

        //** check the specific sensor
        else  check_sensors_value(sensors[index].value);
       
    }

}

//***********************************************************************
//                                
//***********************************************************************
void Alert::check_actuators(Actuator actuators[], short int N_actuators)
{

    short int i; 


    //** check if there is at least one actuator with some alert 
    if (name == "ANY")
    {
        for (i = 0; i < N_actuators; i++)
        {
            check_actuators_value(actuators[i].state);
            if (on) { index = i; break; }
        }
    }

    //** check the specific actuator
    else  check_actuators_value(actuators[index].state);


}

//*******************************************************************
//
//*******************************************************************
short int Alert :: sound_priority(String name)
{
    short int i;

  //  Serial.print(str(" actions =")); Serial.print(actions);
  //  Serial.print(str(" mode =")); Serial.println(mode); 

    if (on && (actions == name || actions == "all"))

        return get_level();

    else return 0;

}




//****************************************************************************************
//	   	Establish the level of the alert. It can be LOW, MEDIUM, HIGH or VERY_HIGH                         
//****************************************************************************************
short int Alert :: get_level()
{
    
    if      (magnitude == "Temperature")	return MEDIUM;
    else if (magnitude == "Humidity")		return MEDIUM;
    else if (magnitude == "Power AC")		return LOW;
    else if (magnitude == "Volts AC")		return LOW;
    else if (magnitude == "I_rms AC")		return LOW;
    else if (magnitude == "kWh")			return LOW;
    else if (magnitude == "Pyranometer")	return MEDIUM;
    else if (magnitude == "Irradiance")		return MEDIUM;
    else if (magnitude == "DC Power")		return LOW;
    else if (magnitude == "DC Current")		return LOW;
    else if (magnitude == "DC Voltage")		return LOW;
    else if (magnitude == "Battery")		return HIGH;
    else if (magnitude == "Push Button")	return HIGH;
    else if (magnitude == "Flow meter")		return MEDIUM;
    else if (magnitude == "Water counter")	return MEDIUM;
    else if (magnitude == "Alarm")			return HIGH;
    else if (magnitude == "Door")			return HIGH;
    else if (magnitude == "AtenTTo aerial") return VERY_HIGH;
    else if (magnitude == "AtenTTo plug")	return VERY_HIGH;
    else if (magnitude == "AtenTTo switch") return VERY_HIGH;
    else if (magnitude == "Blind")			return VERY_HIGH;
    else if (magnitude == "Heat/Cool mode") return VERY_HIGH;
    else if (magnitude == "Heater")			return VERY_HIGH;
    else if (magnitude == "Pump")			return VERY_HIGH;
    else if (magnitude == "Light")			return VERY_HIGH;
    else if (magnitude == "Taisi")			return VERY_HIGH;

}

//*******************************************************************
//
//*******************************************************************
void Alert :: set_email_alert( char state[], Sensor sensors[], Actuator actuators[] )
{
    char char_name[20], char_min_value[7], char_max_value[7], char_value[7];
    float v; 
    
     name.toCharArray(char_name, 20);
     min_value.toCharArray(char_min_value, 7);
     max_value.toCharArray(char_max_value, 7);
     value.toCharArray(char_value, 7);
        

    if (is_sensor)
    { 
        strcat(state, "The sensor: "); strcat(state, char_name);
        reference_group.toCharArray(char_name, 20);
        strcat(state, "  Reference group: "); strcat(state, char_name); 
        strcat(state, "\n has a value: ");
        
        sprintf(char_name, "  %8.2f", sensors[index].value); strcat(state, char_name);

        if (!digital)
        {
            strcat(state, " out of range : [ "); strcat(state, char_min_value);  
            strcat(state, " , "); strcat(state, char_max_value); strcat(state, " ] \n");
            if (name == "ANY")
            {
               sensors[index].label.toCharArray(char_name, 20);
               strcat(state, " The name of this sensor is: "); strcat(state, char_name); strcat(state, "  \n");
            }
            
        }

        else if (value =="NOTNORMAL") strcat(state, " is not NOT NORMAL  ");
       
        else  {  strcat(state, "  is "); strcat(state, char_value); }
       
    }
   
    else
    {
      strcat(state, "The value of the actuator: "); strcat(state, char_name);
      sprintf(char_name, "  %d", actuators[index].state); strcat(state, char_name);

      if (value == "NOTNORMAL") strcat(state, " is not NOT NORMAL  ");

      else { strcat(state, "  is "); strcat(state, char_value); strcat(state, " \n"); }
     
        
    }


}



//**********************************************************************
// Once alerts are checked, actions like beep or emails are carried out 
//**********************************************************************
short int Actions(Time_Date timedate, Sensor sensors[], Actuator actuators[], Alert alerts[], char message[], char state[])
{
    short int i, j, k;
    short int level, max_level;
    char cname[20];
    bool send, sound;


    //**Conditional Alert = Alert_i && Alert_j &&..  
    for (i = 0; i < N_conditions; i++)
    {
        conditions[i].on = true;
        for (j = 0; j < conditions[i].N; j++)
        {
            k = conditions[i].index[j];
            conditions[i].on = conditions[i].on && alerts[k].on;
        }
    }

    strcpy(message, " ");
    strcpy(state, " ");

    //**email for those true conditional alerts every hour
    //  the email is formed with different rows of every alert. 
    //  Different conditionals are sent consecutively
    for (i = 0; i < N_conditions; i++)
        if (conditions[i].on && conditions[i].sent_at_hour != timedate.hour)
        {
            conditions[i].name.toCharArray(cname, 20);
            strcpy(message, " Conditional alert: "); strcat(message, cname);

            for (j = 0; j < conditions[i].N; j++)
            {
                k = conditions[i].index[j];
                send = (alerts[k].actions == "email") || (alerts[k].actions == "all");
                if (send) alerts[k].set_email_alert(state, sensors, actuators);
            }
            conditions[i].sent_at_hour = timedate.hour;
            break;
        }

    //**Sound for those true conditional alerts
    //  Different conditionals are priorized. 
    max_level = 0;

    for (i = 0; i < N_conditions; i++)
        if (conditions[i].on)
            for (j = 0; j < conditions[i].N; j++)
            {
                k = conditions[i].index[j];
                sound = (alerts[k].actions == "sound") || (alerts[k].actions == "all");

                if (sound) level = alerts[k].sound_priority("sound");
				else       level = 0; 

                if (level > max_level) max_level = level;
            }

    Serial.print(str("Sound level = ")); Serial.println(max_level);

    return max_level;


}




//*******************************************************************
//
//*******************************************************************
void Report(Time_Date timedate, Alert alerts[], short int N_alerts,  char message[], char state[])
{

    short int i;

    strcpy(message, " ");
    strcpy(state, " ");


    for (i = 0; i < N_alerts; i++)
        alerts[i].set_report(timedate, state);

    if (strcmp(state," ") !=0 ) strcpy(message, " Report "); 
}
    
//*******************************************************************
//
//*******************************************************************
void Alert :: set_report(Time_Date timedate, char state[])
{
   
    if ( report_periodicity(timedate) ) 
    {
        if (is_sensor) write_sensor_report(state); 
        else           write_actuators_and_digit_sensors_report(state); 

    }
}


//*******************************************************************
// 
//*******************************************************************
bool Alert :: report_periodicity(Time_Date timedate)
{
    byte h = 23, m = 58; // hour and minute to send periodic reports 
   // byte h = 1, m = 26;

    if (timedate.hour == h && timedate.minute == m && sent_at_hour != h)
    {
      Serial.println(str(" ****************Report ***************")); 
      sent_at_hour = h; 
      if (report == "DAILY" )                                    return true;
      else if (report == "WEEKLY"  && timedate.dayOfWeek == 1)   return true;
      else if (report == "MONTHLY" && timedate.dayOfMonth == 1)  return true;
      else if (report == "YEARLY"  && timedate.month == 1)       return true;
      else                                  { sent_at_hour = 25; return false;  }
    }

    else if (timedate.hour == h) return false;
    
    else 
    {
      sent_at_hour = 25; 
      return false;
    }
         
         
    
}


//*******************************************************************
//
//*******************************************************************
void Alert :: write_sensor_report(char state[])
{
    char cname[20], buffer[100];

    name.toCharArray(cname, 20);
    sprintf(buffer, "Sensor:%s Min:%.2f Max:%.2f Mean:%.2f\n", cname, min, max, mean); 
    strcat(state, buffer);

    reference_group.toCharArray(cname, 20);
    sprintf(buffer, "Deviation from Ref.Group (%s): %.2f\n", cname, deviation);

    strcat(state, "____________________________________\n");

    Serial.println(state); 

    reset_values();
}


//*******************************************************************
//
//*******************************************************************
void Alert :: write_actuators_and_digit_sensors_report( char state[])
{
    char cname[20], buffer[100], cvalue[5];
    unsigned int days, hours, minutes;
    long int s; 

    name.toCharArray(cname, 20);
    s = (long)seconds_on; 
    
    minutes = s % 60; hours = s % 3600; days = s % (24 * 3600); 
  
    if (!is_sensor)
    {
        strcpy(state, "Actuator: ");
        strcat(state, cname);
        strcat(state, " \n  ");
        sprintf(buffer, "\tTime ON: %i days, %i hours, %i minutes \tDeviation with the rest of the group (%): %.2f\0", days, hours, minutes, deviation);
        strcat(state, buffer);
    }
    else
    {
        value.toCharArray(cvalue, 5);

        strcpy(state, "Sensor: ");
        strcat(state, cname);
        strcat(state, " \n ");
        
        strcat(state, "\t Time it has been ");
        strcat(state, cvalue);
        sprintf(buffer, ": %i days, %i hours, %i minutes \tDeviation with the rest of the group (%): %.2f\0", days, hours, minutes, deviation);
        strcat(state, buffer);
    }
    reset_values();
}


//**************************************************************
// 
//*******************************************************************
void Alert :: reset_values()
{
    min = 1234.0;
    max = 0.0;
    mean = 0.0;
    sum = 0.0;
    deviation = 0.0;
    N_samples = 0.0;

    seconds_on = 0.0;
     
    Serial.print( str("**********    min =") ); Serial.println(min);
	
	
}








//************************************************************************
//
//************************************************************************
//void update_reference_group_values(Time_Date timedate, float DT, Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators, Alert alerts[], short int N_alerts)
//{
//	short int i, j, k, l;
//    float sum; 
//
//
////  Reference groups: mean values 
//    for (i = 0; i < N_groups; i++)
//    {
//      if (verbose_alert) { print(str("Group = ")); println(RG[i].name); }
//      sum = 0; 
//      for (j = 0; j < RG[i].N; j++)
//        {
//            k = RG[i].index[j]; 
//
//            if (RG[i].any) l = k; 
//            else           l = alerts[k].index;
//
//			if (RG[i].digital)
//			{
//                sum += alerts[k].seconds_on;
//				if (verbose_alert) { print(str("Group seconds on = ")); println(sum); }			
//            }
//			else
//			{
//				sum += sensors[l].value;
//                if (verbose_alert) { print(str("Group value = ")); println(sum); }
//			}
//        }
//      RG[i].mean = sum / RG[i].N; 
//      if (verbose_alert) { print(str("RG mean = ")); println(RG[i].mean); }
//    }
// 
////  Reference groups: typical deviation 
//    for (i = 0; i < N_groups; i++)
//    {
//		sum = 0; 
//		for (j = 0; j < RG[i].N; j++)
//        {
//            k = RG[i].index[j];
//
//            // If the reference group is ANY, then indexes are sensors indexes 
//			// else indexes are alerts which correspond to some sensors 
//			if (RG[i].any) l = k;
//			else           l = alerts[k].index;
//           
//            if (!RG[i].digital) sum += pow(sensors[l].value - RG[i].mean, 2.0); 
//            else                sum += pow(alerts[k].seconds_on - RG[i].mean, 2.0); 
//        }
//        RG[i].deviation = sqrt( sum / RG[i].N ); 
//    }
//
//    if (verbose_alert) 
//    {
//      println(str("Reference groups are built"));
//      for (i = 0; i < N_groups; i++)
//      {
//          print(RG[i].name); 
//          print(str("  mean =")); print(RG[i].mean);
//          print(str("  digital =")); print(RG[i].digital);
//          print(str("  deviation =")); println(RG[i].deviation);
//      }
//    }
//        
//    for (i = 0; i < N_alerts; i++)
//    {
//       j = alerts[i].index_reference_group;
//       alerts[i].RG_mean = RG[j].mean; 
//    }
//    
//    
//}



//*******************************************************************
//
//*******************************************************************
//void Alert :: set_maxmin(Time_Date timedate, float DT, Sensor sensors[], short int N_sensors, Actuator actuators[], short int N_actuators)
//{
//	char buff[150]; 
//	char cname[20]; 
//	
//
//        if (is_sensor && !digital) set_maxmin_sensors(timedate, sensors, N_sensors);
//
//        else                       set_maxmin_actuators(DT, actuators, sensors );
//
//
//        if (verbose_alert)
//        {	
//        name.toCharArray(cname, 20); 
//		sprintf(buff, "Set values of %s is sensor=%d digital=%d\n  max=%.2f  min =%.2f sec_on=%.2f\n ",
//				cname, is_sensor, digital, max, min, seconds_on);
//
//		print(buff); 
//        }
////    }
//
//}



//*******************************************************************
//
//*******************************************************************
//void Alert :: set_maxmin_sensors(Time_Date timedate, Sensor sensors[], short int N_sensors)
//{
//    short int i, j;
//    float v;
//
//    if (name == "ANY")
//    {
//        for (i = 0; i < N_sensors; i++)
//            if (sensors[i].magnitude == reference_group)
//            {
//                v = sensors[i].value; 
//                set_maxmin_sensor(timedate, v); 
//            }
//    }
//    else
//    {
//        v = sensors[index].value;
//        set_maxmin_sensor(timedate, v);
//    }
//
// //   print(" iday in exit set_maxmin_sensors ");  println(tmin.dayOfWeek);
//
//}

//**********************************************************************************
// print time
//**********************************************************************************
//void copy_time(Time_Date &d, Time_Date s)
//{
//
//    d.dayOfWeek = s.dayOfWeek; 
//    d.hour = s.hour; 
//    d.minute = s.minute; 
//    d.second = s.second; 
//    d.year = s.year; 
//    d.month = s.month; 
//    d.dayOfMonth = s.dayOfMonth; 
//
//    println("WARNING copy_time"); 
//    println(d.dayOfWeek); 
//}




//*******************************************************************
//
//*******************************************************************
//void Alert :: set_maxmin_sensor(Time_Date timedate, float v )
//{
//    short int j; 
//  
//    if (v > max)      { max = v; 
//  //  copy_time(&tmax, timedate);
//    tmax.dayOfWeek =  timedate.dayOfWeek;
//    tmax.hour =       timedate.hour;
//    tmax.minute =     timedate.minute;
//    tmax.second =     timedate.second;
//    tmax.year =       timedate.year;
//    tmax.month =      timedate.month;
//    tmax.dayOfMonth = timedate.dayOfMonth;
//
//    }
//    if (v < min)      { 
//       min = v; 
//        //copy_time(&tmin, timedate); 
//        tmin.dayOfWeek = timedate.dayOfWeek;
//        tmin.hour = timedate.hour;
//        tmin.minute = timedate.minute;
//        tmin.second = timedate.second;
//        tmin.year = timedate.year;
//        tmin.month = timedate.month;
//        tmin.dayOfMonth = timedate.dayOfMonth;
//    }
//
// //   print(" iday in set_maxmin_sensor ");  println(tmin.dayOfWeek);
// /*   println("exit WARNING copy_time");
//    println(tmax.dayOfWeek);*/
//    
//    sum += v;
//    N_samples++;
//    mean = sum / N_samples;
//
//    j = index_reference_group; 
//    deviation = 100 * (RG[j].mean - v) / RG[j].mean; 
//
//    //print(str("v =")  );   println(v); 
//    //print(str("min =") );  println(min);
//    //print(str("max =") );  println(max); 
//    //print(str("mean ="));  println(mean);
//    //print(str("index ref group="));  println(j);
//    //print(str("Ref group mean ="));  println(RG[j].mean);
//    //print(str("deviation ="));  println(deviation);
//    
//}

//*******************************************************************
//
//*******************************************************************
//void Alert :: set_maxmin_actuators( float DT, Actuator actuators[], Sensor sensors[])
//{
//    short int j;
//
//    if (!is_sensor) set_actuator_timer( DT, actuators); 
//    else            set_digital_sensor_timer(DT, sensors); 
//
//    j = index_reference_group;
//    deviation = 100 * (RG[j].mean - seconds_on) / RG[j].mean;
//    RG_mean =  RG[j].mean;
//    max = 1; 
//    min = 0; 
//}



//*******************************************************************
//
//*******************************************************************
//void Alert :: set_actuator_timer( float DT, Actuator actuators[] )
//{
//	const unsigned char _on = 1, _down = 2, _off = 0;
//
//    bool actuator_on; 
//
//    actuator_on = actuators[index].state == _on || actuators[index].state == _down; 
//
//    if (actuator_on) seconds_on += DT; 
//
//}

//*******************************************************************
//
//*******************************************************************
//void Alert :: set_digital_sensor_timer(float DT, Sensor sensors[])
//{
//	const float _on = 1.0, _off = 0.0, _open = 1.0, _close = 0.0;
//	float sensor_value;
//	unsigned int milliseconds;
//
//    bool sensor_on; 
//
//
//	if      (value == "ON")		sensor_value = _on;
//	else if (value == "OFF")	sensor_value = _off;
//	else if (value == "OPEN")	sensor_value = _open;
//	else if (value == "CLOSE")	sensor_value = _close;
//
//    sensor_on = sensors[index].value == sensor_value; 
//
//  //  if (sensor_on) seconds_on += DT; 
//
//}




//*********************************************************************************
//		Shows if a value between the same kind of sensors is not normal                  
//*********************************************************************************
//bool Alert :: notnormal(float v)
//{
//    short int i;
//    float xmax, xmin;
//
//    for (i = 0; i < N_groups; i++)
//        if (reference_group == RG[i].name)
//        {
//            xmin = RG[i].mean - 3.0 * RG[i].deviation;
//            xmax = RG[i].mean + 3.0 * RG[i].deviation;
//
//            if (v < xmin || v > xmax) return true;
//            else                      return false;
//        }
//
//    return false;
//
//}
//*******************************************************************
//
//*******************************************************************
//void Alert::set_email_alert(char state[], Sensor sensors[], Actuator actuators[])
//{
//    char char_name[20], c1[7], c2[7], char_value[7];
//    float v;
//    short int i, k, m;
//
//    name.toCharArray(char_name, 20);
//    value.toCharArray(char_value, 7);
//
//
//    if (is_sensor)
//    {
//        strcat(state, "Sensor: ");
//        if (name == "ANY")
//        {
//            sensors[index].label.toCharArray(char_name, 20);
//            strcat(state, char_name);
//        }
//        else strcat(state, char_name);
//
//
//        if (!digital)
//        {
//
//            strcat(state, " has a value: ");
//            sprintf(char_name, "  %6.2f", sensors[index].value); strcat(state, char_name);
//
//            min_value.toCharArray(c1, 7);
//            max_value.toCharArray(c2, 7);
//            strcat(state, " out of range : [ "); strcat(state, c1);
//            strcat(state, " , "); strcat(state, c2); strcat(state, " ] \n");
//
//        }
//
//        else if (value == "NOTNORMAL") strcat(state, " is not NOT NORMAL  ");
//
//        else
//        {
//            strcat(state, "  is "); strcat(state, char_value);
//            time_begin.toCharArray(c1, 7);
//            time_end.toCharArray(c2, 7);
//            strcat(state, " in the schedule : [ "); strcat(state, c1);
//            strcat(state, " , "); strcat(state, c2); strcat(state, " ] \n");
//
//        }
//
//    }
//
//    else
//    {
//        strcat(state, "Actuator: "); strcat(state, char_name);
//        sprintf(char_name, "  %d", actuators[index].state); strcat(state, char_name);
//
//        if (value == "NOTNORMAL") strcat(state, " is not NOT NORMAL  ");
//
//        else { strcat(state, "  is "); strcat(state, char_value); strcat(state, " \n"); }
//
//
//    }
//
//
//}
//
//     else
//     {
//
//     }
//
//
//  name.toCharArray(char_name, 20);
//     value.toCharArray(char_value, 7);
//    
//
//
//
//     
//
//
//
 //   if (is_sensor)
//    { 
//        strcat(state, "Sensor: "); 
//        if (name == "ANY")
//        {
//            sensors[index].label.toCharArray(char_name, 20);
//            strcat(state, char_name); 
//        }
//        else strcat(state, char_name);
//        
//
//        if (!digital)
//        {  
//           
//            strcat(state, " has a value: ");
//            sprintf(char_name, "  %6.2f", sensors[index].value); strcat(state, char_name); 
//
//            min_value.toCharArray(c1, 7);
//            max_value.toCharArray(c2, 7);
//            strcat(state, " out of range : [ "); strcat(state, c1);  
//            strcat(state, " , "); strcat(state, c2); strcat(state, " ] \n");
//         
//        }
//
//        else if (value =="NOTNORMAL") strcat(state, " is not NOT NORMAL  ");
//       
//        else
//        {  
//            strcat(state, "  is "); strcat(state, char_value); 
//            time_begin.toCharArray(c1, 7);
//            time_end.toCharArray(c2, 7);
//            strcat(state, " in the schedule : [ "); strcat(state, c1);
//            strcat(state, " , "); strcat(state, c2); strcat(state, " ] \n");
//
//        }
//       
//    }
//   
//    else
//    {
//      strcat(state, "Actuator: "); strcat(state, char_name);
//      sprintf(char_name, "  %d", actuators[index].state); strcat(state, char_name);
//
//      if (value == "NOTNORMAL") strcat(state, " is not NOT NORMAL  ");
//
//      else { strcat(state, "  is "); strcat(state, char_value); strcat(state, " \n"); }
//     
//        
//    }
//
//
//}


 //******************************************************************************************
// 
//******************************************************************************************
 //short int verify_alerts(char facility[],  Time_Date timedate, short int N_sensors, Sensor sensors[], short int N_actuators, Actuator actuators[],  char main_switch[], char message[], char state[])
 //{
 //    short int i, level;


 //    strcpy(state, "");


 //    //**If Atentto is not OFF, alerts are checked  
 //    if (main_switch != "OFF")
 //    {


 //        //**  Reference groups 
 //        //	  update_reference_group_values(timedate, DT, sensors, N_sensors, actuators, N_actuators, alerts, N_alerts);

 //        //    max, min, mean and deviation from its reference group 
 //        //    If they actuators or digital sensors, total time while they are ON 
 //         //     for (i = 0; i < N_alerts; i++)  alerts[i].set_maxmin(timedate, DT, sensors, N_sensors, actuators, N_actuators);


 //        //**  determine action(beep or email) based on AND conditionals 
 //        level = AtenTTo_warnings(facility, timedate, main_switch, N_sensors, sensors, N_actuators, actuators, N_alerts, alerts, message, state);

 //        //**  writes a report for every alert to be sent by the HUB
 //        //    If actions do not have a pending email then, prepare a report as an email. 
 //              //if (strcmp(state, "") == 0)
 //              //{
 //              // strcpy(message, "********** Report **********");
 //              // for (i = 0; i < N_alerts; i++) if (alerts[i].report != "None") alerts[i].set_report(timedate, state, false);
 //              //}


 //        return level;
 //    }

 //    //**Atentto is OFF 
 //    else return 0;


 //}

    ////**Sound for those true conditional alerts
    ////  Different conditionals are priorized. 
    //max_level = 0;

    //for (i = 0; i < N_conditions; i++)
    //    if (conditions[i].on)
    //        for (j = 0; j < conditions[i].N; j++)
    //        {
    //            k = conditions[i].index[j];
    //            if (alerts[k].actions == "None") continue;
    //            sound = (alerts[k].actions == "sound") || (alerts[k].actions == "all");

    //            if (sound) level = alerts[k].sound_priority("sound");
				//else       level = 0; 

    //            if (level > max_level) max_level = level;
    //        }





    //if (verbose_alert) { print(str("Sound level = ")); println(max_level); } 

    //strcpy(state, "");
//*****************************************
    //for (i = 0; i < N_alerts; i++)
    //    alerts[i].write_email(state, sensors, actuators); 
//*****************************************


   
//*******************************************************************
//
//*******************************************************************
//void Alert :: set_report(Time_Date timedate, char state[], bool always)
//{
//
//    if ( report_periodicity(timedate) || always ) 
//    {
//        if (is_sensor && !digital) write_sensor_report(state);
//        else                       write_actuators_and_digit_sensors_report(state); 
//
//    }
//  
//}


//*******************************************************************
// 
//*******************************************************************
//bool Alert :: report_periodicity(Time_Date timedate)
//{
//    byte h = 23, m = 58; // hour and minute to send periodic reports 
//   // byte h = 1, m = 26;
//
//    if (timedate.hour == h && timedate.minute == m && sent_at_hour != h)
//    {
//      sent_at_hour = h; 
//      if (report == "Daily")                                    return true;
//      else if (report == "Weekly"  && timedate.dayOfWeek == 1)   return true;
//      else if (report == "Monthly" && timedate.dayOfMonth == 1)  return true;
//      else if (report == "Yearly"  && timedate.month == 1)       return true;
//      else                                  { sent_at_hour = 25; return false;  }
//    }
//
//    else if (timedate.hour == h) return false;
//    
//    else 
//    {
//      sent_at_hour = 25; 
//      return false;
//    }
//         
//         
//    
//}


//**********************************************************************************
// print time
//**********************************************************************************
//void time_format(Time_Date time, char ctime[])
//{
//    byte iday;
//    char* days[7] = { "Mon", "Tue", "Wed",  "Thu", "Fri", "Sat", "Sun" };
//
//    iday = time.dayOfWeek;
//  //  print(" iday in time_format = ");  println(time.dayOfWeek);
//
//    sprintf(ctime, "%d:%d:%d  %d/%d/%d  %s ",
//            time.hour, time.minute, time.second,
//            time.dayOfMonth, time.month, time.year, days[iday - 1]);
//
// //   print(" ctime = "); println(ctime);
//
//
//
//}


//*******************************************************************
//
//*******************************************************************
//void Alert :: write_sensor_report(char state[])
//{
//    char cname[20], cmagnitude[20], crgroup[20], buffer[100], ctime[50];
//
//    name.toCharArray(cname, 20);
//    magnitude.toCharArray(cmagnitude, 20);
//    reference_group.toCharArray(crgroup, 20); 
//    
//    
//    if (name == "ANY") strcpy(cmagnitude, crgroup); 
//    sprintf(buffer, "Sensor: %s, Magnitude: %s \n", cname, cmagnitude); strcat(state, buffer);
//    time_format(tmin, ctime); 
//    sprintf(buffer, "Min: %.1f at: %s \n",  min, ctime); strcat(state, buffer);
//    time_format(tmax, ctime);
//    sprintf(buffer, "Max: %.1f at: %s \n", max, ctime); strcat(state, buffer);
//    sprintf(buffer, "Mean: %.1f\n", mean); strcat(state, buffer);
//
//    if (name != "ANY")
//    {
//     sprintf(buffer, "Ref. group: %s",  crgroup); strcat(state, buffer);
//     sprintf(buffer, " mean: %.1f\n", RG_mean); strcat(state, buffer);
//    }
//
//    strcat(state, "____________________________________\n");
//    reset_values();
//}


//*******************************************************************
//
//*******************************************************************
//void Alert :: write_actuators_and_digit_sensors_report( char state[])
//{
//    char cname[20], cmagnitude[20], crgroup[20], buffer[100], cvalue[5];
//    unsigned int days, hours, minutes;
//    long int s; 
//
//
//    name.toCharArray(cname, 20);
//    magnitude.toCharArray(cmagnitude, 20);
//    reference_group.toCharArray(crgroup, 20);
//    value.toCharArray(cvalue, 5);
//
//    s = (long)seconds_on; 
//    
//    days = s / (24 * 3600); 
//    s = s - days * 24 * 3600;
//    hours = s / 3600; 
//    s = s - hours * 3600; 
//    minutes = s / 60;
//
//    if (!is_sensor)
//    {
//        sprintf(buffer, "Actuator: %s, Device: %s\n", cname, cmagnitude); strcat(state, buffer);        
//        sprintf(buffer, "Time ON: %i days, %i hours, %i minutes\n", days, hours, minutes); strcat(state, buffer);
//        sprintf(buffer, "Ref. group: %s \n", crgroup); strcat(state, buffer);
//    }
//    else
//    {
//     sprintf(buffer, "Sensor: %s, Device: %s\n", cname, cmagnitude); strcat(state, buffer);
//     sprintf(buffer, "It has been  %s : %i days, %i hours, %i minutes \n", cvalue, days, hours, minutes); strcat(state, buffer);
//     sprintf(buffer, "Ref. group: %s \n",  crgroup); strcat(state, buffer);
//    }
//
//    strcat(state, "____________________________________\n");
//    reset_values();
//}

//**********************************************************************************
// print time
//**********************************************************************************
//void ini_time(Time_Date time)
//{
//
//
//    time.hour = 0;
//    time.minute = 0;
//    time.second = 0;
//
//    time.dayOfWeek = 1;
//    time.dayOfMonth = 1;
//    time.month = 1;
//    time.year = 2020;
//
//}


//**************************************************************
// 
//*******************************************************************
//void Alert :: reset_values()
//{
//    min = 1e6;
//    max = -1e6;
//    ini_time(tmax); 
//    ini_time(tmin);
//
//
//    mean = 0.0;
//    sum = 0.0;
//    deviation = 0.0;
//    N_samples = 0;
//
//    seconds_on = 0.0;
//     
// //   print( str("**********    min =") ); println(min);
//}




